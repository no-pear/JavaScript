## 任务一：函数式编程

### 函数相关复习
+ 函数是一等公民
+ 高阶函数
+ 闭包

### 函数式编程基础
- lodash
- 纯函数
相同的输入总是得到相同的输出
- 柯里化
    + 当一个函数有多个参数的时候先传递一部分参数调用它
    + 然后返回一个新的函数接收剩余的参数，返回结果
    + 多元函数转为单元函数
- 管道
- 函数组合

### 函子
```
容器：包含值和值的变形关系(这个变形关系就是函数) 
函子：是一个特殊的容器，通过一个普通的对象来实现，
该对象具有 map 方法，map 方法可以运行一个函数对值进行处理(变形关系) 
```
+ Functor
```
总结
函数式编程的运算不直接操作值，而是由函子完成 
函子就是一个实现了 map 契约的对象 
我们可以把函子想象成一个盒子，这个盒子里封装了一个值 
想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这 个函数来对值进行处理 
最终 map 方法返回一个包含新值的盒子（函子
```
+ MayBe
`
MayBe 函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）
`
+ Either
`Either 两者中的任何一个，类似于 if...else...的处理 异常会让函数变的不纯，Either 函子可以用来做异常处理
`
+ IO
```
IO 函子中的 _value 是一个函数，这里是把函数作为值来处理 
IO 函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯的操作(惰性执行)，包装当前的操 作纯 
把不纯的操作交给调用者来处理
```
+ Task
    - folktale
+ Pointed
`
Pointed 函子是实现了 of 静态方法的函子 of 方法是为了避免使用 new 来创建对象，更深层的含义是 of 方法用来把值放到上下文 Context（把值放到容器中，使用 map 来处理值
`
+ Monad

## 任务二：异步编程
### 同步模式
### 异步模式
#### 回调函数
#### promise
+ 基本用法
+ 链式调用
+ 异常处理
+ 静态方法
    - Promise.resolve()
    - Promise.reject()
+ 并行执行
    - Promise.all()
    - Promise.race()
+ 执行时序
    - 宏任务
    - 微任务
#### generator
#### async/await

## 任务三：手写 Promise
1. 定义 myPromise 类
2. 执行器
3. res
    + 判断状态是否为pending改为fulfilled
4. rej
5. then
    + 根据状态指定相应的回调
    + 异步调用保存回调
    + 链式调用
        - return 本身 报错提示
6. 导出

## 直播
#### ES2018
+ 展开和剩余在对象的使用
+ 正则表达式的增强
+ 正则组命名
+ Promise.prototype.finally()
#### ES2019
+ 数组稳定排序
+ try...catch 参数可省略
#### ES2020
+ 空值运算符
+ 可选链运算符
+ Promise.allSettled()
+ BigInt
+ 动态导入